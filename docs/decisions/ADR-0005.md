# ADR: Formato de Output de Claude ‚Äî JSON Estructurado

**ID**: ADR-0005
**Fecha**: 2026-02-15
**Estado**: üü° Propuesto
**Autor**: Claude / Aritz

## 1. Contexto y Problema

Claude genera contenido complejo para OPTEK: tests tipo test con 4 opciones y justificaciones legales, correcciones de desarrollos con 5 dimensiones de evaluaci√≥n, y evaluaciones orales. Este contenido debe ser parseado por c√≥digo, verificado determin√≠sticamente, almacenado en BD, y renderizado en UI. Necesitamos decidir el formato de comunicaci√≥n entre Claude y nuestra aplicaci√≥n.

## 2. Opciones Consideradas

- **Opci√≥n A**: JSON estructurado ‚Äî Definir schemas JSON estrictos para cada tipo de output. Claude genera JSON que se parsea con `JSON.parse()` y se valida con Zod.
- **Opci√≥n B**: Texto libre con parsing posterior ‚Äî Claude genera texto natural. Luego extraemos datos con regex o un segundo LLM.
- **Opci√≥n C**: XML/Markdown estructurado ‚Äî Usar tags XML o headings Markdown como estructura, m√°s flexible que JSON pero menos tipado.
- **Opci√≥n D**: Function calling / Tool use ‚Äî Usar la API de tool_use de Anthropic para que Claude "llame funciones" con par√°metros tipados.

## 3. Decisi√≥n Elegida: JSON Estructurado

**Justificaci√≥n T√©cnica**:

1. **Parsing determinista**: `JSON.parse()` es O(n) y determinista. No hay ambig√ºedad en la estructura. Si el JSON es v√°lido, los datos est√°n donde esperamos.
2. **Validaci√≥n con Zod**: Cada output se valida contra un schema Zod tipado. Si Claude omite un campo o devuelve un tipo incorrecto, se detecta inmediatamente y se puede reintentar.
3. **Compatibilidad con verificaci√≥n**: El pipeline de verificaci√≥n determinista necesita acceder a citas en ubicaciones predecibles (`response.preguntas[0].justificacion.citas`). Con texto libre, esto ser√≠a fr√°gil.
4. **Tipado end-to-end**: Schema Zod ‚Üí tipo TypeScript ‚Üí componente React. Un solo cambio en el schema se propaga con type safety.
5. **Almacenamiento eficiente**: Los campos JSONB de Supabase almacenan directamente el output de Claude sin transformaci√≥n.
6. **Claude es excelente en JSON**: Con instrucciones claras y ejemplos en el prompt, Sonnet genera JSON v√°lido >98% de las veces.

**Schemas definidos** (en `directives/OPTEK_prompts.md`):

- `TestGenerado`: { preguntas: [{ enunciado, opciones, correcta, justificacion: { texto, citas } }] }
- `CorreccionDesarrollo`: { puntuacion_global, dimensiones: [5], errores, citas_recomendadas }
- `EvaluacionOral`: { puntuacion, dimensiones, preguntas_tribunal }

## 4. Consecuencias (Trade-offs)

- **Positivas**: Parsing fiable (>98%), type safety end-to-end, integraci√≥n directa con Supabase JSONB, compatible con verificaci√≥n determinista, cacheable.
- **Negativas/Riesgos**: Claude puede generar JSON inv√°lido (~2% de las veces). Mitigaci√≥n: retry con prompt m√°s estricto (max 1 retry). Si persiste, error al usuario. Los schemas JSON son r√≠gidos: a√±adir campos requiere actualizar schema + validaci√≥n + tipos (mitigado: Zod `.passthrough()` para forward-compatibility).

## 5. Notas de Implementaci√≥n

- Schemas Zod en `/lib/ai/schemas.ts` (derivados de `directives/OPTEK_prompts.md`).
- Validaci√≥n post-parse en `/lib/ai/claude.ts`: `schema.safeParse(JSON.parse(response))`.
- Si `safeParse` falla: retry 1 vez con instrucci√≥n adicional "Responde SOLO con JSON v√°lido, sin texto adicional".
- Campo `prompt_version` en BD para trazar qu√© versi√≥n de prompt gener√≥ cada output.
- Tests unitarios en `tests/unit/schemas.test.ts` con ejemplos v√°lidos e inv√°lidos.
